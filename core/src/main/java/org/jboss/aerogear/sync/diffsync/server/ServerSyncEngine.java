/**
 * JBoss, Home of Professional Open Source
 * Copyright Red Hat, Inc., and individual contributors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * 	http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.jboss.aerogear.sync.diffsync.server;

import org.jboss.aerogear.sync.diffsync.ClientDocument;
import org.jboss.aerogear.sync.diffsync.DefaultBackupShadowDocument;
import org.jboss.aerogear.sync.diffsync.DefaultClientDocument;
import org.jboss.aerogear.sync.diffsync.DefaultShadowDocument;
import org.jboss.aerogear.sync.diffsync.Document;
import org.jboss.aerogear.sync.diffsync.Edits;
import org.jboss.aerogear.sync.diffsync.ShadowDocument;

/**
 * The server side of the differential synchronization implementation.
 *
 * @param <T> The type of document that this implementation can handle.
 */
public class ServerSyncEngine<T> {

    private final ServerSynchronizer<T> synchronizer;
    private final ServerDataStore<T> dataStore;

    public ServerSyncEngine(final ServerSynchronizer<T> synchronizer, final ServerDataStore<T> dataStore) {
        this.synchronizer = synchronizer;
        this.dataStore = dataStore;
    }

    /**
     * Determines if a document exists in this sync engine.
     *
     * @param id the document id.
     * @return {@code true} if the document exists in this engine
     */
    public boolean contains(final String id) {
       return dataStore.getDocument(id) != null;
    }

    /**
     * Adds a new document which is "synchonrizable".
     *
     * A server does not create a new document itself, this would be created by a client
     * and a first revision is added to this synchronization engine by this method call.
     *
     * @param document the document to add.
     */
    public void addDocument(final Document<T> document, final String clientId) {
        if (!contains(document.id())) {
            dataStore.saveDocument(document);
        }
        addShadow(document.id(), clientId);
    }

    /**
     * Performs the server side patching for a specific client.
     *
     * @param clientEdits the changes made by a client.
     */
    public void patch(final Edits clientEdits) {
        final Document<T> document = getDocument(clientEdits.documentId());
        final ShadowDocument<T> shadowDocument = patchShadow(clientEdits);
        patchDocument(document, shadowDocument);
    }

    /**
     * Performs the server side diff which is performed when the server document is modified.
     * The produced {@link Edits} can be sent to the client for patching the client side documents.
     *
     * @param clientId the clientId for whom we should perform a diff and create edits for.
     * @param documentId the document in question.
     * @return {@link Edits} The server edits, or updates, that were generated by this diff .
     */
    public Edits diff(final String clientId, final String documentId) {
        final Document<T> document = getDocument(documentId);
        final Edits edits = serverDiffs(document, clientId);
        patchShadow(edits);
        return edits;
    }

    private void addShadow(final String documentId, final String clientId) {
        final Document<T> document = getDocument(documentId);
        final ClientDocument<T> clientDocument = newClientDocument(clientId, documentId, document.content());
        // A clients shadow always begins with server version 0, and client version 0. Even if the server document
        // has existed for days and has been updated many time, the server version of the shadow is specific to this
        // client. The server version represents the latest version of the server document that the client has seen.
        saveShadow(newShadowDoc(0, 0, clientDocument));
    }

    private Edits clientDiffs(final Document<T> document, final ShadowDocument<T> shadow) {
        final Edits newEdits = clientDiff(document, shadow);
        final Edits pendingEdits = getPendingEdits(shadow.document().clientId(), document.id());
        return merge(pendingEdits, newEdits);
    }

    private Edits serverDiffs(final Document<T> document, final String clientId) {
        final ShadowDocument<T> shadow = getShadowDocument(clientId, document.id());
        final Edits newEdits = serverDiff(document, shadow);
        final Edits pendingEdits = getPendingEdits(clientId, document.id());
        final Edits mergedEdits = merge(pendingEdits, newEdits);
        saveShadow(incrementServerVersion(shadow));
        return mergedEdits;
    }

    private ShadowDocument<T> patchShadow(final Edits edits) {
        final ShadowDocument<T> shadow = getShadowDocument(edits.clientId(), edits.documentId());
        final ShadowDocument<T> patchedShadow = synchronizer.patchShadow(edits, shadow);
        return saveShadow(incrementClientVersion(patchedShadow));
    }

    private Document<T> patchDocument(final Document<T> document, final ShadowDocument<T> shadowDocument) {
        final Edits edits = clientDiffs(document, shadowDocument);
        final Document<T> patched = synchronizer.patchDocument(edits, document);
        saveDocument(patched);
        saveBackupShadow(shadowDocument);
        return patched;
    }

    private Document<T> getDocument(final String documentId) {
        return dataStore.getDocument(documentId);
    }

    private ClientDocument<T> newClientDocument(final String clientId, final String documentId, final T content) {
        return new DefaultClientDocument<T>(documentId, content, clientId);
    }

    private ShadowDocument<T> getShadowDocument(final String clientId, final String documentId) {
        return dataStore.getShadowDocument(documentId, clientId);
    }

    private Edits getPendingEdits(final String clientId, final String documentId) {
        return dataStore.getEdit(clientId, documentId);
    }

    private Edits clientDiff(final Document<T> doc, final ShadowDocument<T> shadow) {
        return synchronizer.clientDiff(doc, shadow);
    }

    private Edits serverDiff(final Document<T> doc, final ShadowDocument<T> shadow) {
        return synchronizer.serverDiff(doc, shadow);
    }

    private static Edits merge(final Edits pendingEdits, final Edits newEdits) {
        if (pendingEdits == null) {
            return newEdits;
        }
        pendingEdits.diffs().addAll(newEdits.diffs());
        return pendingEdits;
    }

    private void saveEdits(final Edits edits, final Document<T> document) {
        dataStore.saveEdits(edits, document);
    }

    private ShadowDocument<T> incrementClientVersion(final ShadowDocument<T> shadow) {
        final long clientVersion = shadow.clientVersion() + 1;
        return newShadowDoc(shadow.serverVersion(), clientVersion, shadow.document());
    }

    private ShadowDocument<T> saveShadow(final ShadowDocument<T> newShadow) {
        dataStore.saveShadowDocument(newShadow);
        return newShadow;
    }

    private ShadowDocument<T> newShadowDoc(final long serverVersion, final long clientVersion, final ClientDocument<T> doc) {
        return new DefaultShadowDocument<T>(serverVersion, clientVersion, doc);
    }


    private ShadowDocument<T> incrementServerVersion(final ShadowDocument<T> shadow) {
        final long serverVersion = shadow.serverVersion() + 1;
        return newShadowDoc(serverVersion, shadow.clientVersion(), shadow.document());
    }

    private void saveBackupShadow(final ShadowDocument<T> newShadow) {
        dataStore.saveBackupShadowDocument(new DefaultBackupShadowDocument<T>(newShadow.clientVersion(), newShadow));
    }

    private void saveDocument(final Document<T> document) {
        dataStore.saveDocument(document);
    }

    private void clearPendingEdits(final Edits edits) {
        //TODO: clear out pending edits.
    }

}
